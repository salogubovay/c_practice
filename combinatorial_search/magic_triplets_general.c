/*
Алгоритм формирования магических троек.

Заметим следующее:
    1) структуру троек можно разделить на 2 кольца: внутреннее и внешнее
    2) внутреннее кольцо состоит из n чисел, каждое из которых используется в двух тройках
    3) внешнее кольцо тоже состоит из n чисел, каждое из которых используется только в одной тройке
    4) структура троек нужно заполнить числами от 1 до 2 * n
    5) сумма во всех тройках должна быть одинаковая
    6) минимальная сумма в тройке >= 2 * n (максимальное число, которое можно использовать для заполнения)
    7) максимальная сумма в тройке <= 2 * n + 2 * n - 1 + 2 * n - 2 (сумма трёх самых больших чисел, которые можно использовать для заполнения)
    8) зная сумму, которой должны равняться все тройки, достаточно заполнить числа только во внутреннем кольце (число во внешнем кольце можно рассчитать как сумма тройки - сумма двух чисел внутреннего кольца)
    9) количество способов заполнения внутреннего кольца - это число размещений из 2n элементов по n элементов = (2n)! / (2n - n)!

Описание алгоритма поелного перебора для заполнения внутреннего кольца:
    1) сгенерируем все возможные размещения из 2n элементов по n элементов во внутреннем кольце
    2) переберём все возможные суммы троек: от (2 * n) до (2 * n + 2 * n - 1 + 2 * n - 2)
    3) для каждой суммы последовательно будем пытаться заполнить внешнее кольцо для каждого размещения во внутреннем кольце
        а) если рассчитанное число во внешнем кольце < 1 или > 2 * n, то остановить заполнение и перейти к другой сумме
        б) если рассчитанное число во внешнем кольце > нулевого элемента внешнего кольца, то остановить заполнение (так как нам нужно вывести наборы троек в лексикографическом порядке)
    4) для каждой позиции (pos) заполнения внешнего кольца поддерживается следующий инвариант:
        а) все числа, использованные в заполнении внутреннего и внешнего колец, различны
        б) суммы всех ранее заполненных троек одинаковые

Оценка сложности алгоритма полного перебора для заполнения внутреннего кольца:
    1) количество возможных сумм троек = 2 * n + 2 * n - 1 + 2 * n - 2 - 2 * n = 2 * (n + 1) - 3
    2) количество чисел для заполнения внутреннего кольца = 2 * n
    3) количество чисел во внутреннем кольце = n
    Приблизительная сложность алгоритма = O(n * (2 * n) ^ n)

--------------------------------------------------------------------------------------------------------------------
Описание алгоритма оптимизированного заполнения внутреннего кольца (предыдущая версия программы):
    1) переберём все возможные суммы троек: от (2 * n) до (2 * n + 2 * n - 1 + 2 * n - 2)
    2) для каждой суммы последовательно будем заполнять внутреннее кольцо ранее неиспользованными числами
    3) для каждого заполненного элемента внутреннего кольца с индексом pos >= 1 будем рассчитывать число во внешнем кольце:
        а) если рассчитанное число во внешнем кольце < 1 или > 2 * n, то остановить заполнение и вернуться на одну позицию назад в заполнении внутреннего кольца
        б) если рассчитанное число во внешнем кольце > нулевого элемента внешнего кольца, то остановить заполнение (так как нам нужно вывести наборы троек в лексикографическом порядке) и вернуться на одну позицию назад в заполнении внутреннего кольца
    4) для каждой позиции (pos) заполнения внутреннего кольца поддерживается следующий инвариант:
        а) все числа, использованные в заполнении внутреннего и внешнего колец, различны
        б) суммы всех ранее заполненных троек одинаковые
    5) когда мы заполнили внутреннее кольцо (дошли до позиции pos = n) нам остаётся проверить последний элемент внешнего кольца, если он не использовался, то выводим получившийся набор троек и возвращаемся на одну позицию назад в заполнении внутреннего кольца.
--------------------------------------------------------------------------------------------------------------------
*/

#include <stdio.h>
#include <stdlib.h>
#include "combinatorics.h"

static void read_input(int *pn) {
    int res = scanf("%d", pn); if ((res != 1) || (*pn < 3)) {
        printf("Incorrect input\n");
        abort();
    }
}

static void print_magic_triplets(struct array *outerCircle, int * innerCircle) {
    for (int i = 0; i < outerCircle->size; ++i) {
        printf("%d,%d,%d", outerCircle->a[i], innerCircle[i], innerCircle[(i + 1) % outerCircle->size]);
        if (i != (outerCircle->size - 1)) {
            printf("; ");
        }
    }
    printf("\n");
}

static void fill_used_numbers(struct array *usedNumbers, struct array2d *a2d, int idx) {
    fill_array_with_zeros(usedNumbers);
    for (int j = 0; j < a2d->c; ++j) {
        usedNumbers->a[a2d->a[idx][j]] = 1;
    }
}

static void fill_outer_circle(struct array *outerCircle, struct array *usedNumbers, struct array2d *a2d, int idx, int sum) {
    int pos = 0;

    for (int i = 0; i < outerCircle->size; ++i) {
        int nextNum = sum - a2d->a[idx][i] - a2d->a[idx][(i + 1) % a2d->c];
        if ((nextNum >= 1) && (nextNum < usedNumbers->size) && (usedNumbers->a[nextNum] == 0)) {
            if (i > 0 && outerCircle->a[0] > nextNum) {
                return;
            } 
            usedNumbers->a[nextNum] = 1;
            outerCircle->a[i] = nextNum;
        } else {
            return;
        }
    } 
    
    print_magic_triplets(outerCircle, a2d->a[idx]); 
}

static void generate_triplets(struct array2d *a2d, int n) {
    int maxSum; 
    struct array innerCircle, outerCircle, usedNumbers;
    init_array(&outerCircle, n);
    init_array(&usedNumbers, 2 * n + 1);
    maxSum = 2 * n + 2 * n - 1 + 2 * n - 2;

    for (int s = 2 * n; s <= maxSum; ++s) {
        for (int i = 0; i < a2d->r; ++i) {
            fill_used_numbers(&usedNumbers, a2d, i);
            fill_outer_circle(&outerCircle, &usedNumbers, a2d, i, s);
        }
    }

    free_array(&outerCircle);
    free_array(&usedNumbers);
}

int main() {
    struct array2d *a2d;
    int n;
    printf("Enter number of triplets: ");
    read_input(&n);
    a2d = generate_arrangements(2 * n, n);
    generate_triplets(a2d, n);
    free_array2d(a2d);
    free(a2d);
    return 0;
}
